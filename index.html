<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>tinybc(1) manual page</title>
</head>
<body bgcolor='white'>
<a href="http://sourceforge.net/projects/tinybc/"><b>SourceForge project page (download)</b></a><p><p>
<a href="http://tinybc.sourceforge.net/tinybctut.txt"><b>Tiny BASIC manual for beginners</b></a><br><br>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
tinybc - Tiny BASIC for Curses 

<p>  <b>tinybc</b> [OPTIONS]<i>[FILE]</i> <br>

<p> 
<h2><a name='sect1' href='#toc1'>Description</a></h2>
<b>tinybc</b> is a BASIC interpreter for the curses character screen
handling library which fully corresponds to the Tiny BASIC specification.

<p> The tinybc engine is thread-safe and can be embedded into other code. Embedding
may not make sense because of the capabilities of the interpreter, but
it makes sense because the code is easily extendable. 
<p> It&rsquo;s just an idea
i got and quickly implemented, BASIC is not a programming language which
i use. I made it for fun and i hope that it would be used for fun, such
as a minimalist challenge. 

<p> 
<h2><a name='sect2' href='#toc2'>Curses</a></h2>
Curses is a library for using computer
interactively in a character mode. It corresponds to the POSIX standard,
and is the most cross-platform solution for that purpose. Character mode
is the easiest to code, so it is the easiest to feel the computer that
way. Terminals of the modern computers provide almost the same "graphics"
as some earliest microcomputers, and there are many games with such graphics.

<p> 
<h2><a name='sect3' href='#toc3'>Tiny BASIC</a></h2>
Tiny BASIC is the specification of the most minimal BASIC. In
fact, there is not much to choose from, because the next smallest specification
is the Standard for Minimal BASIC, and this does not provide a minimal language
at all. The Tiny BASIC specification was written by Dennis Allison and was
published in the People&rsquo;s Computer Company newsletter in December 1975. The
specification was necessary because of the need to have a small interpreter
which can fit into 2 KB of memory. Tiny BASIC was one of the first programming
languages for the microcomputers. 
<p> This
interpreter is minimal not because it was difficult to add more functionality,
adding functionality is surprisingly simple. This interpreter is minimal
because it is meant to implement Tiny BASIC. But i think that minimalism
enables creatity. 
<p> This interpreter is mostly based on the Tom Pittman's Tiny BASIC, except the USR function and using full expressions for input. The Tom Pittman's Tiny BASIC is implemented so completely that the programs written in it run without modifications. The computed GOTO and GOSUB are implemented too, but their expressions would be renumbered when they only consist of a single number. Two additional features are taken from the Palo Alto Tiny BASIC, one big array named @, and using relation operators in expressions. This enables to run programs written in Palo Alto Tiny BASIC with some modifications. 
<p> 
<h2><a name='sect4' href='#toc4'>Options</a></h2>

<dl>

<dt><b>-i</b></dt>
<dd>Starts
the interpreter interactively and loads the file. </dd>

<dt><b>-number</b></dt>
<dd>Renumbers the program starting from
number. 
<p> </dd>
</dl>

<h2><a name='sect5' href='#toc5'>Install</a></h2>
To compile tinybc in Linux, type make in the terminal. To install tinybc, as root type make install, and to remove the installation, type make remove. The install also copies the examples to the directory /usr/share/doc/tinybc . To compile tinybc in Windows, type one of the following depending on your system: 

<p> mingw32-make tinybc.exe 
<p> make tinybc.exe 
<p> The binaries for Linux
and Windows are provided, but because of viruses, etc, it&rsquo;s safer to compile.
The program depends only on some version of the curses library. For compiling
in Linux, the ncurses development package has to be installed. In Windows,
the compiler such as MinGW has to be installed. If you install MinGW, add its
bin directory to the path. The PDCurses library for Windows is included
in the distribution. 
<p> The path of the directory of the temporary input and output files should be set to the environment variable TINYBC_TMP , otherwise these files shall be stored in the current directory. The path must end with either slash or backslash.
<p> 
<h2><a name='sect6' href='#toc6'>Language Description</a></h2>
The features such as an array were added in order to make tinybc as advanced as Tiny BASIC, not more advanced. Because in spite that the Tiny BASIC specification provides no arrays, most of the Tiny BASIC interpreters at the time (1976) enabled some memory access, thus providing a data storage similar to array. Such memory access also enabled to read program statements, which could been used to read pre-defined data. In tinybc, assigning strings and lists of expressions to array is provided to compensate the lack of DATA statement in Tiny BASIC.
<p>
These interpreters also had a direct access to input/output port, and they could also send escape sequences to the display. The statements OUT, INKEY, and the other curses statements provide that in tinybc. It was possible to run system functions. It was also possible to write any output to paper tape and read any input from paper tape. The input/output redirection and copying and pasting to the terminal cannot fully emulate this, but the SYSTEM statement provides that functionality.
<p>
Because of lack of the if and while blocks, Tiny BASIC does not correspond to the modern programming paradigm. To avoid a "spaghetti code", one solution is to mark all the destinations of jumps with REM statements, such as REM SUB DrawPixel (X, Y), REM DO, REM ELSE and REM END IF, and use lines only consisting of a line number for making the code clearer. Contrary to the popular misunderstanding, the original Tiny BASIC had no FOR...NEXT loop.

<p>
It is difficult to provide the simplest language which is usable for some purposes and which still corresponds to some standard. Inevitably it is necessary to omit a lot which is present in advanced BASIC because it is not possible to add it all to a simple BASIC. Adding even a single seemingly simple feature can be enough to make the language not simple or not standard. Making a simple language is a matter of such delicate balance.
<p> 
<h2><a name='sect7' href='#toc7'>Program statements</a></h2>
In statements, all lines must begin with a number. It
is not always necessary though that the numbers are different or in a growing
order. The line numbers are required because Tiny BASIC is a traditional
BASIC. The lines can also be renumbered. See the examples (the files with
the bas extension). The LET and THEN keywords can be omitted, the PRINT
keyword can be abbreviated as PR. 
<p> 
<dl>

<dt><b>CLS</b></dt>
<dd>Clears the screen </dd>

<dt><b>COLOR expr1, expr2</b></dt>
<dd>Changes
the foreground color to expr1 and background color to expr2 </dd>

<dt><b>END</b></dt>
<dd>Ends the
execution of the program, can be anywhere in the program </dd>

<dt><b>GOSUB expr</b></dt>
<dd>Executes
a subroutine which starts with the number which is the value of the expression,
subroutine ends with RETURN </dd>

<dt><b>GOTO expr</b></dt>
<dd>Executes the line with the number
which is the value of the expression </dd>

<dt><b>IF expr THEN statement</b></dt>

<dd>Executes statement if the value of the expression is not zero </dd>

<dt><b>INCHAR variable</b></dt>
<dd>Writes the code of the
character at the current location into the variable </dd>

<dt><b>INPUT variable, ... variable</b></dt>
<dd>Inputs
variables </dd>

<dt><b>INKEY variable</b></dt>
<dd>Inputs a key code, -1 if no keys pressed </dd>

<dt><b>LET variable
= expr</b></dt>
<dd>Assigns an expression to variable </dd>

<dt><b>LET @(expr) = string|expr, ... string|expr</b></dt>
<dd>Assigns the expressions and characters from strings to consecutive array elements </dd>

<dt><b>LOCATE expr1, expr2</b></dt>
<dd>Moves cursor to line
expr1 and column expr2, the next PRINT prints to that location </dd>

<dt><b>NAP expr</b></dt>

<dd>Sleeps
the expr of milliseconds, a NAP statement should be in the main loop to give
time for the operating system </dd>

<dt><b>OUT expr</b></dt>
<dd>Prints a character, the code of which is the expression </dd>

<dt><b>PRINT string|expr, .... string|expr</b></dt>
<dd>Prints the strings and expressions,
; allowed </dd>

<dt><b>REM comment</b></dt>
<dd>Any text can be written after REM as a comment </dd>

<dt><b>RETURN</b></dt>
<dd>Ends the subroutine block and executes the line after the calling GOSUB statement</dd>

<dt><b>SYSTEM expr1, expr2</b></dt>
<dd>Filters the text in array starting at expr2 through the external command starting at expr1, both end with 0</dd>

<p>
</dl>

<h2><a name='sect8' href='#toc8'>Interactive mode</a></h2>
In the interactive mode you can both edit and run the program. Interactive mode is a part of the Tiny BASIC specification, so it has to be implemented in every language which is said to be Tiny BASIC. The HELP statement is added. LOAD and SAVE are also additional statements which are not in the Tiny BASIC specification. Because in the early computers, they used teletypes as terminals, and so there was no difference whether the input or ouput was done with a typewriter, or with a punched tape. 
<p>
As it is the tradition of BASIC, the first character can be written instead
of the full keyword.
<p> When you write a line which starts with a number, then this
is considered to be a program line and it will be added to program to
the appropriate place. When the number is the number of an existing statement,
then this statement will be replaced with the statement which you entered.
If the line consists only of a number, then the
statement with that number will be deleted. 
<p> 
<dl>

<dt><b>CLEAR</b></dt>
<dd>Deletes the program </dd>

<dt><b>LIST</b></dt>
<dd>Lists
the whole program </dd>

<dt><b>LIST line</b></dt>
<dd>Lists the line </dd>

<dt><b>LIST line1-line2</b></dt>

<dd>Lists program
from line1 to line2 </dd>

<dt><b>LOAD filename</b></dt>
<dd>Loads program from file </dd>

<dt><b>QUIT</b></dt>
<dd>Exits </dd>

<dt><b>RUN</b></dt>
<dd>Runs the program </dd>

<dt><b>SAVE [filename]</b></dt>
<dd>Saves the
program </dd>

<dt><b>HELP</b></dt>
<dd>Prints help 
<p> </dd>
</dl>

<h2><a name='sect9' href='#toc9'>Variables</a></h2>
There is no separate memory allocated for variables in tinybc, all memory remaining in the program buffer after the program can be used as data. The first 26 * 4 bytes of it is used for variables, and the rest of it is used for array. All the data space is filled with zeroes in the beginning of running the program, so one can consider that the initial values of all variables and array elements are 0.
<p>

There are 26 variables, the names of
which are the upper case letters A--Z. Variables are integers, but these are
quite long integers with up to 10 decimal places. This enables to do real
number calculations assuming that the point is somewhere in the middle
of the number.
<p>
As in Palo Alto Tiny BASIC, there is one big array named @, the size of which is all memory in the program buffer remaining from the program and variables. As in 68000 Tiny BASIC, array elements are 32 bit integers the same as variables.
<p> 
<h2><a name='sect10' href='#toc10'>Expressions</a></h2>
The order of calculations is natural (multiplications,
etc., first). 
<p>
One constant named SIZE can be used in expression. This is taken from the Palo Alto Tiny BASIC. The value of that constant is the memory remaining in the program buffer, the maximum size of the @ array is thus SIZE/4.
<p>
 One function, RND(expr) , can be used in expression. This function
generates a random number. Example: assign to the variable N a random number
in the range 1 to 10: 
<p> 10 N = RND(10) + 1 
<p> Expressions can contain variables,
numbers, and the following operators: 
<p> 

<dl>

<dt><b>+</b></dt>
<dd>Addition </dd>

<dt><b>-</b></dt>
<dd>Subtraction </dd>

<dt><b>*</b></dt>
<dd>Multiplication
</dd>

<dt><b>/</b></dt>
<dd>Division </dd>

<dt><b>()</b></dt>
<dd>Parentheses, the expression in parentheses is calculated first

<p> </dd>
</dl>

<h2><a name='sect11' href='#toc11'>Relations</a></h2>
The elements of a relation are expressions. The relation operators can also be used in expressions, with the lowest priority. This enables the expressions like (A > B) * (A < C) , where * and + are used as and and or, respectively. The relation operators are the following: 
<p> 

<dl>

<dt><b>&lt;</b></dt>
<dd>Less </dd>

<dt><b>&lt;=</b></dt>
<dd>Less or equal </dd>

<dt><b>&gt;</b></dt>
<dd>Greater </dd>

<dt><b>&gt;=</b></dt>

<dd>Greater or equal </dd>

<dt><b>=</b></dt>
<dd>Equal
</dd>

<dt><b>&lt;&gt;</b></dt>
<dd>
Not equal 
<p> </dd>
</dl>

<h2><a name='sect12' href='#toc12'>Colors</a></h2>

Most terminals support 8 colors, so currently 8 colors
are allowed (colors 0--7). The combination of foreground and background color
provided in the color statement is called a color pair. The number of color
pairs is restricted and the maximum number depends on your terminal. For
example my terminal allows 64 color pairs. When you try to use one color
combination more than your terminal allows, the color will not change. The
curses colors are not the best possible and they can be re-defined in the
code, but they are the only standard colors, so currently
the colors are the original curses colors. 
<p> 
<h2><a name='sect13' href='#toc13'>Strings</a></h2>
Strings are sequences of characters between quotation marks in the program text. For example "Hello World!" in the following statement is a string:
<p>
10 PRINT "Hello World!"
<p>
You have to set your
terminal encoding to IBM850, which is the MS-DOS encoding, to be able to
print the pseudographics characters. The explanation why it is implemented
like that is rather technical. You  can print ASCII characters in any encoding.

<p> Make sure that you provide a NAP statement after a print statement, or if you use locate, after locate statement, in a bigger loop. To make sure that the previous graphics operation is finished, otherwise the output may be weird. 
<p> 
<h2><a name='sect14' href='#toc14'>Running</a></h2>
The Tiny BASIC programs
can run both in the interactive mode and from the command line. Because
programs which use Curses can write everywhere on the screen, the screen
is cleared when the program terminates. Therefore remember to press any
key when the program is finished, to go back to command line. This enables
to always see the result of the program. 
<p> When the program asks for input,
one can enter both numbers and variable names. In case of variable names,
the corresponding input would be the value of the variable. 

<p> If your program
provides no way to exit normally, ctrl-c should do that harmlessly to the
operating system and to the terminal (but not to your BASIC program). In
Windows, the key for interrupting the program is ctrl-break, the break key
is a key in the upper right corner of the keyboard, with "Pause" written
on it. 
<p> Programs written both in Linux and Windows run, but do not use Notepad to edit Linux files in Windows, use less primitive editor such as Wordpad, but not a word processor. When copying Windows text files to Linux, they must be converted with tr -d '\r' or with a text editor. Input and output redirection works with Curses, also it is possible to copy from the terminal and paste to the terminal. 
<p> 
<h2><a name='sect15' href='#toc15'>Troubleshooting</a></h2>
If
the program exits unnormally, like when you happen to divide by zero, it
may happen that your terminal settings would be changed. It depends on your
terminal how to restore the default settings. Running a tinybc program that
exits normally can restore the settings. But if nothing else helps, closing
the terminal and running it again will always restore the settings, as
running tinybc does not change anything permanently. 
<p> The debug mode can
be switched on by defining the DEBUG symbol in Makefile and compiling. When
the debug mode is on, the debug messages would be written to a log file.
This information is verbous though, so avoid too much looping when debugging.

<p> 
<h2><a name='sect16' href='#toc16'>License</a></h2>
LGPL <p>

<hr><p>

<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Description</a></li>
<li><a name='toc2' href='#sect2'>Curses</a></li>
<li><a name='toc3' href='#sect3'>Tiny BASIC</a></li>
<li><a name='toc4' href='#sect4'>Options</a></li>
<li><a name='toc5' href='#sect5'>Install</a></li>
<li><a name='toc6' href='#sect6'>Language Description</a></li>

<li><a name='toc7' href='#sect7'>Program statements</a></li>
<li><a name='toc8' href='#sect8'>Interactive mode</a></li>
<li><a name='toc9' href='#sect9'>Variables</a></li>
<li><a name='toc10' href='#sect10'>Expressions</a></li>
<li><a name='toc11' href='#sect11'>Relations</a></li>
<li><a name='toc12' href='#sect12'>Colors</a></li>
<li><a name='toc13' href='#sect13'>Strings</a></li>
<li><a name='toc14' href='#sect14'>Running</a></li>
<li><a name='toc15' href='#sect15'>Troubleshooting</a></li>

<li><a name='toc16' href='#sect16'>License</a></li>
</ul>
</body>
</html>

